## 项目说明

- 您作为中文母语的全栈工程师、高级 UI 设计师和高级产品经理，负责本项目的前后端开发、功能设计以及 UI 设计，所有注释与交互文案使用中文。
- 本项目为管理平台模版项目，前端采用 React + TypeScript + Zustand + Ant Design，后端采用 NestJS + TypeScript + Prisma + SQLite。
- 所有回答应使用中文。
- 本仓库是 pnpm 的 monorepo 项目，包含 `frontend` 和 `backend` 两个子项目，依赖管理统一使用 `pnpm`，部分通用依赖安装在根目录的 package 中以避免重复安装。

## Agent 工作规范

### AGENT文档规范

- 除非用户明确要求，否则不要生成新的文档，但是允许修订旧文档。
- 所有由 Agent 在本项目工作过程中产生的临时文件（中间产物、缓存、日志、草稿等）必须创建在项目根目录的 `.agent` 目录下，不得在其他目录散落生成临时文件，除非用户明确要求。
- 如果用户明确要求生成文档，那么每个任务使用独立子目录（例如 `.agent/<date>-<task-name>/`）归档该任务的记录和中间文件，便于追踪与清理。

### 工作流程（4 阶段）

#### 阶段 0：需求理解与上下文收集

- 在开始任何开发或修改前，先对仓库进行结构化快速扫描：确认本次任务涉及的子项目、关键目录、所要参考的代码风格。
- 与用户确认本次任务的业务目标和边界：包括接口契约（输入/输出、错误码）、数据流向、性能或安全要求等；对不明确部分必须用清单形式向用户提问澄清。
- 检查现有文档、代码注释和类似功能实现，记录当前实现现状与潜在风险点（例如：业务规则不一致、缺少测试、数据库变更风险等）。

#### 阶段 1：任务规划

- 深度思考（sequential-thinking）
- 基于阶段 0 的信息，先输出本次任务的验收契约：
  - 预期输入与输出（包括边界与异常场景）。
  - 覆盖的模块/接口/页面列表。
  - 需要通过的测试或验证方式（如具体测试文件、`pnpm` 命令、手动验证步骤）。
- 列出详细的 plan 和 TODO 项，以"可执行小步骤"为单位，至少包含：要修改的文件/模块、预期改动点、是否新增/修改测试以及可能的回滚方案。
- 如涉及新增函数/类/接口，必要时先在规划中给出大致签名、数据结构与错误处理策略，再征求用户确认。
- 将上述 plan/TODO 明确展示给用户，等待用户审核确认后再进入代码改动阶段；如用户未确认或提出异议，需要先完成对齐再继续。

#### 阶段 2：代码执行

- 按照 plan 小步迭代实现，每次改动保持项目处于可编译、可通过类型检查的状态；尽量只修改与任务强相关的模块和文件，避免一次性跨多个无关模块；涉及的逻辑应同步补充或调整测试用例，而不是仅修改实现。
- 严格遵循项目既有的编码规范与风格：包括文件组织方式、命名约定、导入顺序、错误处理模式以及前后端的分层边界，不自创与现有风格冲突的模式。
- 优先复用项目中已有的工具函数、组件、Hook、服务和通用模块，避免为一处需求自研重复能力或引入炫技写法。
- 在未得到用户明确要求的情况下，Agent 过程中不进行 git 提交、不执行长时间 dev 运行、不做 build 构建或破坏性数据库迁移；涉及删除核心配置、修改数据库结构或大范围重构前，必须先征求用户确认。

#### 阶段 3：结果验证与交付

- 根据阶段 1 约定的验收契约逐项自查：确保相关接口/页面按预期工作，类型检查、ESLint 检查与关键测试用例通过，没有未处理的错误日志或明显告警。
- 在最终回复中用结构化方式列出：本次改动影响的文件/模块列表、主要变更点、新增/修改的测试及其验证结论，以及后续建议或已知限制。
- 清理不再需要的临时文件与实验性代码片段，保证工作结果可直接被接手和继续迭代。

### 开发哲学

- 渐进式迭代，小步快跑，保持每次改动可编译、可验证，优先让小范围变更尽早通过类型检查和测试再继续扩展。
- 实现前先研读现有代码与文档，优先复用官方或主流生态方案以及项目中已有的通用模块，避免不必要的自研与炫技式实现。
- 简单优先：坚持单一责任原则，相同或相似逻辑至少出现三次再考虑抽象，避免过早设计复杂框架或通用层。
- 严格遵循既有风格与约定（导入顺序、命名方式、格式化规则、构建与测试框架）。
- 开发前需主动查找至少 3 个项目内相似特性或组件，学习并沿用其复用方式与测试编排模式，保证一致的用户体验与工程实践。
- 对于冗余与过时实现，在确认不再需要后应及时删除，而不是长期保留多个分支逻辑；需要破坏性变更时，通过阶段 0/1 提前向用户说明影响范围并取得确认。
- 核心业务逻辑与易踩坑部分必须配简洁明了的中文功能解释注释，避免后续维护者只能从实现细节反推意图。
- 当需要提交代码时，git commit 信息应以 `feat`、`fix`、`chore` 等前缀开头，并用简体中文描述具体改动内容。

## 项目架构

### 仓库结构（pnpm workspace）

```
hoshi-platform/
├── frontend/                  # 前端（Vite）
│   ├── src/
│   │   ├── assets/            # 静态资源
│   │   ├── components/        # 公共组件
│   │   ├── pages/             # 页面（按业务模块组织）
│   │   ├── router/            # 路由配置
│   │   ├── services/          # API 常量与请求封装（fetch）
│   │   ├── stores/            # Zustand 状态管理（按业务模块拆分）
│   │   ├── types/             # 前端类型定义
│   │   ├── utils/             # 公共工具方法
│   │   ├── index.css          # 全局样式
│   │   ├── main.tsx           # 应用入口文件
│   │   └── vite-env.d.ts      # Vite 类型声明
│   └── .env                   # 前端环境变量
├── backend/                   # 后端（NestJS）
│   ├── src/
│   │   ├── businessModules/   # 业务模块（controller/service/module）
│   │   ├── commonModules/     # 通用模块（controller/service/module）
│   │   ├── common/            # 通用基础模块（exceptions/interceptors等）
│   │   ├── app.module.ts      # 根模块
│   │   └── main.ts            # 入口
│   ├── prisma/                # Prisma schema/seed
│   └── types/                 # 共享类型（DTO/Response，前端会直接引用）
└── pnpm-workspace.yaml
```

## 开发规范

### 类型系统规范

- 禁止使用 `any`；接口 DTO/响应类型优先复用 `backend/types/*`，避免在前端重复定义。
- 接口入参必须使用 class DTO，结合 `class-validator` 与 `class-transformer` 进行校验与转换。
- 响应数据允许使用 type，若使用 class 作为响应 DTO，字段装饰器需完整，并包含默认值/可选性说明。
- 前端消费侧统一使用后端导出的 type，避免引入装饰器与运行时依赖。
- 前后端共享类型放在 `backend/types` 目录下供前后端共用（以 type 为主，仅作工具/辅助）。
- 仅前端视图专用的临时类型，才在对应模块就近定义。
- 前端路径别名 `@` 指向 `frontend/src`（见 `frontend/vite.config.ts`）。

### 命名约定

- 组件命名采用 PascalCase。
- 变量/函数使用 `camelCase`，类/接口用 PascalCase，常量用 `UPPER_SNAKE_CASE`。
- 前后端文件命名优先采用各自既有约定规则；在无明确约定时，文件名统一使用驼峰命名法 `camelCase`。

## 前端开发规范

### 基础规范

- Props 必须明确定义 TypeScript 类型。
- `useEffect` 必须明确声明依赖项。
- 公共逻辑提取为自定义 Hook 或 HOC。

### 前端分层约定

前端以"页面/组件/状态/请求"进行职责划分：

1. **视图层（UI 组件）**：`frontend/src/pages/` 与 `frontend/src/components/`，负责展示与交互。
2. **状态管理层（Zustand store）**：`frontend/src/stores/`，承载业务状态与页面数据拉取/更新逻辑。
3. **接口与请求层**：`frontend/src/services/apis.ts` 管理端点常量，`frontend/src/services/base.ts` 统一封装 fetch 与错误提示。

### 状态管理（Zustand）

Store 按业务模块拆分在 `frontend/src/stores/`，并尽量保持文件粒度与页面模块一致。

- **导出约定**：每个 store 文件默认导出一个 `useXxxStore`；禁止在 store 文件中通过解构方式"导出零散 state/action"。
- **使用方式**：组件内优先用 selector 读取（例如 `useXxxStore(state => state.list)`），避免一次性订阅整个 store 导致无效渲染。
- **组件外读取**：需要在非 React 场景读取状态时，使用 `useXxxStore.getState()`。
- **异步 action**：统一 `try/catch/finally` 管理 loading，并在成功后刷新列表/统计。

### 请求与响应

- **请求封装**：基础请求封装于 `frontend/src/services/base.ts`（基于 fetch），端点常量集中在 `frontend/src/services/apis.ts`。
- **成功/失败判断**：后端统一响应结构 `ResponseBody<T> = { code, msg, data }`，成功判断以 `code === ErrorCode.SUCCESS (10000)` 为准。
- **错误提示**：统一使用 `msg` 作为错误文案，兜底 `res?.msg || '默认错误信息'`；前端已在请求层做 `notification` 提示，调用侧按需捕获即可。
- **认证相关**：当前项目未接入完整登录流程，如后续引入登录页，可在请求层统一处理 401/过期跳转。

## 前端样式规范

- 样式方案优先级：Ant Design > Tailwind CSS > CSS Modules。
- 避免使用全局样式，保持全局视觉风格一致。
- 加载状态优先使用骨架屏。

### 设计原则

- 整体风格追求简洁、高端、极简，如同瑞士 SPA 般的质感。
- 设计标准：让专业人士愿意为之付费，让 Steve Jobs 也会微笑的品质。

### 视觉与交互

- 图标：使用图标而非 emoji。
- 配色：避免不必要的颜色使用，从统一的调色板中选取并保持一致。
- 间距：确保每个组件间距恰当——既不过于紧凑也不过于分散。

### 响应式

- 确保在桌面端和移动端都保持优雅的响应式体验。

## 后端开发规范

- 遵循 NestJS 最佳实践。
- 接口必须统一使用 POST 方法。
- 使用 Prisma 处理数据库操作。
- 业务错误需返回合适的错误信息，优先使用自定义的 `BusinessException` 搭配 `ErrorCode`，当前错误类型不满足时在 `ErrorCode` 中新增。
- 接口入参使用 class DTO 验证类型的合法性，使用 Pipe 验证业务上的合法性。
- 简单的、通用的业务逻辑可以抽取为 Pipe 以便于复用。
- `businessModules` 是业务模块，`commonModules` 是通用模块，`common` 中是通用组件。
